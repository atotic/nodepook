<link href="../vendor/polymer/polymer.html" rel="import">
<link href='../vendor/paper-button/paper-button.html' rel="import">
<link href='../vendor/paper-ripple/paper-ripple.html' rel="import">

<polymer-element name='pook-animate-list'>
<template>
  <style>
    .tile {
      position: relative;
      display: inline-block;
      width: 100px;
      height: 100px;
      border: 1px solid black;
      user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-user-select: none;
    }
    .tile.animate-add {
            z-index: 999;
            background-color: white;
    -webkit-animation-duration:2s;
            animation-duration:2s;
    -webkit-animation-name:slide-up;
            animation-name:slide-up;
    }

    .tile.animate-remove {
      -webkit-animation-duration:0.5s;
              animation-duration:0.5s;
      -webkit-animation-name:fade-out;
              animation-name:fade-out;    
    }
    @-webkit-keyframes slide-up {
      from { top: 80vh; width:0px; }
      to { top: 0px; width: 100px;  }
    }
    @keyframes slide-up {
      from { top: 80vh; width:0px; }
      to { top: 0px; width: 100px; }
    }
    @-webkit-keyframes fade-out {
      from { opacity: 1.0; }
      to { opacity: 0; width: 0; }
    }
    @keyframes fade-out {
      from { opacity: 1.0; }
      to { opacity: 0; width: 0; }
    }
  </style>
  <p>
    <paper-button on-tap="{{addValue}}" raised>Add</paper-button>
    click on tile to delete
  </p>
  <section id='books' layout horizontal wrap>
    <template id='bookList' repeat="{{k in keys}}">

        <div layout horizontal center center-justified class='tile {{ k | computeTileClass }}' 
          on-click="{{removeValue}}" 
          on-animationend="{{handleTileAnimationEnd}}" 
          on-webkitAnimationEnd="{{handleTileAnimationEnd}}"  
          on-mozAnimationEnd="{{handleTileAnimationEnd}}"
        >
        <paper-ripple fit class=""></paper-ripple>
        {{model[k].title}}
        </div>
    </template>
  </section>
</template>
<script>

  // lifted a utility funciton from http://andrew-hoyer.com/experiments/numbers/
var names = [{"0":"zero","1":"one","2":"two","3":"three","4":"four","5":"five","6":"six","7":"seven","8":"eight","9":"nine" },{"0":"ten","1":"eleven","2":"twelve","3":"thirteen","4":"fourteen","5":"fifteen","6":"sixteen","7":"seventeen","8":"eighteen","9":"nineteen"},{"2":"twenty","3":"thirty","4":"forty","5":"fifty","6":"sixty","7":"seventy","8":"eighty","9":"ninety"},["","thousand","million","billion","trillion","quadrillion","quintillion","sextillion","septillion","octillion","nonillion","decillion","undecillion","duodecillion","tredecillion","quattuordecillion", "quindecillion","sexdecillion","septdecillion","octdecillion","novemdecillion","vigintillion"]];
var to_words = function(s, n){
    var ns = s.slice(0,3);
    return (ns.length < 1)?"":to_words(s.slice(3,s.length),n+1)+((ns.length>1)?((ns.length==3&&ns[2]!="0")?names[0][ns[2]]+" hundred "+((ns[1]=="1")?names[1][ns[0]]+" ":(ns[1]!="0")?names[2][ns[1]]+" "+((ns[0]!="0")?names[0][ns[0]]+" ":""):(ns[0]!="0"?names[0][ns[0]]+" ":"")):((ns[1]=="1")?names[1][ns[0]]+" ":(ns[1]!="0")?names[2][ns[1]]+" "+((ns[0]!="0")?names[0][ns[0]]+" ":""):(ns[0]!="0"?names[0][ns[0]]+" ":""))) + (((ns.length==3&&(ns[0]!="0"||ns[1]!="0"||ns[2]!="0"))||(ns.length==2&&(ns[0]!="0"||ns[1]!="0"))||(ns.length==1&&ns[0]!="0"))?"":""):((ns.length==1&&ns[0]!="0")?names[0][ns[0]]+" ":"") + (((ns.length==3&&(ns[0]!="0"||ns[1]!="0"||ns[2]!="0"))||(ns.length==2&&(ns[0]!="0"||ns[1]!="0"))||(ns.length==1&&ns[0]!="0"))?"":""));
}
  Polymer({
    publish: {
      keys: [], // keys of mode
      delta: {
        add: {}, // # key => true
        remove: {} // # key => index in old array
      },
      model: {}
    },
    ready: function() {
      this.appendModel();
      this.appendModel();
      this.appendModel();
      this.appendModel();
      this.appendModel();
      this.appendModel();
      this.appendModel();
      this.appendModel();
      this.appendModel();
      this.appendModel();
      this.appendModel();
      this.appendModel();
      this.appendModel();
      this.keys = this.computeKeys();
    },
    appendModel: function() {
      if (!('nextItemId' in this))
        this.nextItemId = 0;
      var key = (this.nextItemId++).toString();
      var title = key === "0" ? "zero" : to_words(key.split('').reverse(), 0);
      title = title.charAt(0).toUpperCase() + title.slice(1);
      this.model[ key] = { title: title };
    },
    computeKeys: function() {
      return Object.keys(this.model).reverse();
    },
    findTemplateInstanceByKey: function(k) {
      var instances = this.$.books.querySelectorAll('.tile');
      for (var i=0; i<instances.length; i++)
        if (instances.item(i).templateInstance.model.k === k)
          return instances.item(i);
    },
    modelChanged: function() {
      var newKeys = this.computeKeys();
      this.delta = this.computeDelta(newKeys, this.keys);
      // reinsert deleted keys for animation, keeping the position
      var removes = [];
      for (var k in this.delta.remove)
        removes.push({ id: k, index: this.delta.remove[k]});
      removes.sort( function(a,b) { return a.index - b.index });
      removes.forEach( function(r) { newKeys.splice( r.index, 0, r.id)});
      // kick off remove animation
      for (var i=0; i<removes.length; i++) {
        var el = this.findTemplateInstanceByKey( removes[i].id);
        if (!el)
          console.error('could not find deleted element');
          el.classList.add('animate-remove');
      }
      // finally, assign new keys
      this.keys = newKeys;
    },
    // [a,b,c] => { a: 0, b: 1, c: 2}
    arrayToHash: function(arry) {
      var retVal = {};
      for (var i=0; i<arry.length; i++)
        retVal[arry[i]] = i;
      return retVal;
    },
    computeDelta: function(newKeys, oldKeys) {
      var newHash = this.arrayToHash( newKeys );
      var oldHash = this.arrayToHash( oldKeys );
      var delta = {
        add: {},
        remove: {}
      };
      for (var k in newHash) {
        if ( k in oldHash )
          delete oldHash[k];
        else
          delta.add[k] = true;
      }
      // keys deleted from newHash are still in oldHash
      for (var k in oldHash)
        delta.remove[k] = oldHash[k];
      return delta;
    },
    addValue: function() {
      this.appendModel();
      this.modelChanged();
    },
    removeValue: function(ev) {
      console.log("removing", this.model[ev.currentTarget.templateInstance.model.k]);
      delete this.model[ev.currentTarget.templateInstance.model.k];
      this.modelChanged();
    },
    computeTileClass: function(k) {
      if (k in this.delta.remove)
        return 'animate-remove';
      if (k in this.delta.add)
        return 'animate-add';
      return '';
    },
    handleTileAnimationEnd: function(ev) {
      var target = ev.currentTarget;
      var key = target.templateInstance.model.k;
      var classTag = target.classList.contains('animate-remove') ? 'animate-remove' :
                      target.classList.contains('animate-add') ? 'animate-add' : "";
      // remove class tag
      ev.currentTarget.classList.remove(classTag);
      // remove from delta list
      delete this.delta[ classTag.replace('animate-', '')][key];
      switch (classTag) {
        // removed 
        case 'animate-remove':
          // remove item from the the list of actives
          this.keys.splice(this.keys.indexOf(key), 1);
          break;
        default:
          break;
      }
    }
  });
</script>
</polymer-element>
