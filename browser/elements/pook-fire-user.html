<link href="../vendor/polymer/polymer.html" rel="import">
<link href="async.html" rel="import">

<!--
/**
  * pook-fire-user represents current user
  * publishes uid
  *
  * @element pook-fire-user
 */
-->
<polymer-element name='pook-fire-user'>
  <template>
  </template>
  <script>
  (function() {

  "use strict";

  // Firebase server
  var gFireServer = 'https://torid-inferno-6070.firebaseio.com/';

  // Shared user information
  var gUserInfo = {
    /**
     * uid can have three values:
     * '' means uninitialized
     * 'anonymous' means user not logged in
     * everything else is auth.uid
     */
      uid: '',
      email: '' 
  };
 
  /* 
  Shared databases as firebase-element objects
  state can have 3 values:
  false: database has not been requested
  true: database has been requested
  object: this is the database, firebase-element
  databases are created when user logged in && requested with requestDatabase  user is logged in, 
  */  
  var gDatabases = {
    account: false,
    user: false,
    userPhotos: false,
    userBookList: false,
  };

  /* 
    Cache of pook-proxy-photo objects
     Use this to access photo data. requestPhotoProxy() requests data in cache
  */
  var gPhotoCache = {
    // photoId: pook-proxy-photo
  }

  /*
   * exif parser worker
   */
  var gExifWorker;
  function initExifWorker() {
    if (gExifWorker !== undefined)
      return console.error("initExifWorker called multiple times");
    gExifWorker = new Worker('/elements/exif-worker.js');
    gExifWorker.addEventListener('message', function(ev) {
      switch(ev.data.action) {
        case 'parsed':
          if (gPhotoCache[ev.data.photoId]) {
            // console.log('got exifParse', ev.data.exif);
            gPhotoCache[ ev.data.photoId ].setLocalExifData(ev.data.exif);
          }
          else
            console.warn('photo parsed, but no photo in cache', photoId);
          break;
        default:
          console.warn('unknown message', ev.data);
      }
    });
  }

  /**
   * task: { photoId: id, file: FileObject }
   */
  var PhotoUploadProcessor = function(task, done) {

    function processSuccess(xhr) {
      if (gPhotoCache[task.photoId]) {
        /* xhr response:
        {"msg":"Photo created","item":{"dateTime":"2011:04:19 20:59:58","dateTimeOriginal":"2010:12:20 17:00:00","width":3648,"height":2736,"contentType":"image/jpeg","dateTaken":"2010-12-21T01:00:00.000Z","md5":"82cb9d01c03c7c80e3d1852ae205671a","s3id":"PoLBWE_fiXbmipGaaa.jpg"}
        */
        var response = JSON.parse(xhr.response);
        var item = response.item;
        var newData = {
          s3: item.s3id,
          width: item.width,
          height: item.height
        };
        ['dateTaken', 'caption', 'latitude', 'longitude','latitudeRef','longitudeRef'].forEach( function(k) {
          if (k in item)
            newData[k] = item[k];
        });
        // console.log(newData);
        gPhotoCache[task.photoId].progress = -1;
        gPhotoCache[task.photoId].ref.update(newData, function(err) {
          if (err)
            console.error("error updating ", gPhotoCache[taskphotoId].location, err);
        });
      }
      else {
        console.warn("missing photo after upload");
      }
      done();
    };

    function processFaiure(xhr, ev) {
      console.error('photo upload failed', task);
      if (gPhotoCache[task.photoId]) {
        gPhotoCache[photoId].progress = -1;
      }
      done(new Error("Task failed"));
      // push the task back on the queue
      task.failCount = ('failCount' in task) ? ( task.failCount + 1 ) : 1;
      if (task.failCount < 5)
        PhotoUploadQueue.unshift(task);
      else if (gPhotoCache[task.photoId])
        gPhotoCache[task.photoId].uploadFailed();
    }

    function start() {
      var fd = new FormData();
      fd.append('myPhoto', task.file);

      var xhr = new XMLHttpRequest();
      // success/failure
      xhr.addEventListener('load', function onload(e) {
        switch(this.status) {
          case 200:
            processSuccess(xhr);
            break;
          default:
            processFaiure(xhr, e);
            break;
        }
      });
      // xhr.addEventListener('readystatechange', function readystate(ev) {
      //   if (xhr.readystate === 4) // DONE
      //     THIS.completedTask();
      // });
      // upload progress
      xhr.upload.addEventListener('progress', function progress(ev) {
        var photo = gPhotoCache[task.photoId];
        if (!photo)
          return;
        if (ev.lengthComputable && ev.total != 0)
          photo.progress = ev.loaded / ev.total;
        else
          photo.progress = -1;
      });
      xhr.open('POST', '/photos');
      xhr.send(unwrap(fd));     
    };

    start();
  }

  var PhotoUploadQueue = async.queue( PhotoUploadProcessor, 2);

  // Pause photo uploads when not online
  window.addEventListener('offline', function(ev) {
    console.log('paused');
    PhotoUploadQueue.pause();
  });
  window.addEventListener('online', function(ev) {
    console.log('resumed');
    PhotoUploadQueue.resume();
  });

  /* 
   * authClient listens to authentication events
   */
  var gAuthClient;  // FirebaseSimpleLogin, used to listen to authentication events
  function initAuth() {
    if (gAuthClient) // only init once
      return;
    // Listen to authentication events
    gAuthClient = new Firebase(gFireServer);
    gAuthClient.onAuth( function(user) {
        gUserInfo.uid = user ? user.uid : 'anonymous';
        gUserInfo.email = user ? user.password.email : '';
      }
    );
  }
  initAuth();

  var PookFireUser = {
    publish: {
      /** if set, will redirect to anonRedirect path if user is 'anonymous' */
      anonRedirect: '',
      userInfo: false,
      databases: false,
      photoCache: { value: {}}
    },
    computed: {
      uid: 'userInfo.uid',
      email: 'userInfo.email',
      account: "databases['account'].data",
      userPhotos: "databases['userPhotos'].data",
      userData: "databases['user'].data"
    },
    observe: {
      uid: 'userStatusChanged'
    },
    created: function() {
      this.userInfo = gUserInfo;
      this.databases = gDatabases;
      this.photoCache = gPhotoCache;
    },
    userStatusChanged: function() {
      // console.log("userStatusChanged", this.uid);
      this.connectActiveDatabases();
      // redirect anonymous if necessary
      if (this.uid === 'anonymous' && this.anonRedirect != '')
        window.location.replace(window.location.origin + this.anonRedirect);
    },
    requestDatabase: function(type) {
      if (!(type in this.databases))
        return console.error("bad database request", type);
      // console.log('requestDatabase:', type);
      if (this.databases[type] === false)
        this.databases[type] = true;
      this.connectActiveDatabases();
    },
    connectActiveDatabases: function() {
      if (this.uid === 'anonymous' || this.uid === '') {
        // no user, remove active databases
        for (var k in this.databases)
          if ((typeof this.databases[k]) === 'object')
            this.databases[k] = true;
      }
      else {
        for (var k in this.databases)
          if (this.databases[k] === true) {
            this.databases[k] = document.createElement('firebase-element');
            this.databases[k].location = this.getDatabaseUrl(k);
            // this.databases[k].log = true;
            if (k == 'account') {
              var obs = new PathObserver(this.databases[k], 'data.email');
              obs.open( function(newValue, oldValue) {
                console.log('email changed');
                if (oldValue && newValue)
                  console.log('email really changed');
              });

            }
          }
      }
    },
    getDatabaseUrl: function(type, options) {
      switch(type) {
        case 'user':
          return gFireServer + "users/" + this.uid;
        case 'account':
          return gFireServer + "users/" + this.uid + "/account";
        case 'userPhotos':
          return gFireServer + "photos/" + this.uid;
        case 'userBookList':
          return gFireServer + "users/" + this.uid + "/books";
        case 'onePhoto': // options is photoId
          return gFireServer + "photos/" + this.uid + "/" + options;
        case 'oneBook': // options is bookId
          return gFireServer + "books/" + this.uid + "/" + options;
        default:
          console.error("unknown database type", type);
      }
    },
    getFirebase: function(type) {
      if (!(type in this.firebases))
        return console.error('bad firebase type', type);
      if (!this.firebases[type])
        this.firebases[type] = new Firebase(this.getDatabaseUrl(type));
      return this.firebases[type];
    },
    requestPhotoProxy: function(photoId) {
      if (photoId in this.photoCache)
        return;
      this.photoCache[photoId] = document.createElement('pook-proxy-photo');
      this.photoCache[photoId].user = this;
      this.photoCache[photoId].photoId = photoId;
    },
    logout: function() {
      gAuthClient.unauth();
    },
    createPhoto: function(file) {
      this.requestDatabase('userPhotos');

      // if databases not ready, reschedule
      if (!this.databases['userPhotos'] || 
          !this.databases['userPhotos'].ref) {
        this.async(function() {
          this.createPhoto(file);
        }, null, 1000);
        return;
      }
      var photoRec = {
        createdAt: Firebase.ServerValue.TIMESTAMP,
        displayName: file.name
      }

      // add to user's photos
      var photoRef = this.databases['userPhotos'].push(photoRec);
      // request a proxy
      this.requestPhotoProxy(photoRef.name());
      this.exifWorker.postMessage({action: 'parse', file: file, photoId: photoRef.name() });
      // upload via xhr
      PhotoUploadQueue.push( {photoId: photoRef.name(), file: file});
    },
    createBook: function(title, size) {

    },
    randomString: function (len, charSet) {
      charSet = charSet || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      var randomString = '';
      for (var i = 0; i < len; i++) {
          var randomPoz = Math.floor(Math.random() * charSet.length);
          randomString += charSet.substring(randomPoz,randomPoz+1);
      }
      return randomString;
    },
    get exifWorker() {
      if (gExifWorker === undefined)
        initExifWorker();
      return gExifWorker;
    }
  }

  Polymer(PookFireUser);

  })();
  </script>
</polymer-element>
