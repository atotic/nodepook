<link href="../vendor/polymer/polymer.html" rel="import">
<link href="pook-utils.html" rel="import">
<link rel="import" href="pook-book-cache.html">
<link rel="import" href="pook-photo-cache.html">

<!--
Current user model, singleton (all instances share state)

Holds `firebase-element` references to user databases.

Users are authenticated asynchronously. Databases get data after authentication.
If you are using bindings, you do not need to worry about this, otherwise:

    user = document.createElement('pook-user');
    
@element pook-user
@group model

-->
<polymer-element name='pook-user' anonRedirect="">
  <template></template>
  <script>
  (function() {

  "use strict";

  // Stuff common to all pook-user instances
  var Singleton = {
  
    // user information, from firebase.onAuth
    userInfo: {
    /**
     * @property uid
     * @type string
     * uid can have three states:
     *
     * "" means uninitialized
     *
     * 'anonymous' means user not logged in
     *
     * everything else is auth.uid
     */
      uid: '',
    /**
     * @property email
     * @type string
     */
      email: ''
    },
    authClient: new Firebase( CommonUtils.firebaseLoc ),

    /* 
    User related databases
    User databases contain $userId in their path, and can only be loaded after we know userId
    Requests for user database return Promise, which is fullfilled when user authenticates

    state can have 3 values:
    false: database has not been requested
    true: database has been requested
    object: this is the database, firebase-element
    */  
    databases: {
      account: false,
      user: false,
      myPhotos: false,
      myBooks: false,
      notifications: false,
      booksSharedWithMe: false
    },
    photoCache: null, // document.createElement('pook-photo-cache'),
    bookCache: null //document.createElement('pook-book-cache')
  };

  Singleton.authClient.onAuth( function(user) {
      Singleton.userInfo.uid = user ? user.uid : 'anonymous';
      Singleton.userInfo.email = user ? user.password.email : '';
    }
  );

  function initSingleton() {
    if (Singleton.photoCache !== null)
      return;
    Singleton.photoCache = document.createElement('pook-photo-cache');
    Singleton.bookCache = document.createElement('pook-book-cache');
    Object.keys( Singleton.databases ).forEach(function(k) {
      Singleton.databases[k] = document.createElement('firebase-element');
    });
  };

  Polymer({
    publish: {
      /** if set, will redirect to anonRedirect path if user is 'anonymous' */
      anonRedirect: '',
      userInfo: null,
      databases: null,
      /**
       * @property photoCache
       * @type pook-photo-cache
       */
      photoCache: null,
      /**
       * @property bookCache
       * @type pook-book-cache
       */
      bookCache: null
    },
    computed: {
      uid: 'userInfo.uid',
      email: 'userInfo.email',
      /**
       * @property account
       * @type object
       * convenience access to /users/$userId/account
       * must use this instead of userData.account.street1 because bindings only broadcast changes 1 deep
       */
      account: "databases['account'].data",
      /** 
       * @property userData
       * Firebase( /users/$userId )
       */ 
      userData: "databases['user'].data",
      myPhotos: "databases['myPhotos'].data",
      myBooks: "databases['myBooks'].data",
      notifications: "databases['notifications'].data",
      booksSharedWithMe: "databases['booksSharedWithMe'].data",

      accountDb: "databases['account']",
      userDb: "databases['user']",
      myPhotosDb: "databases['myPhotos']",
      myBooksDb: "databases['myBooks']",
      notificationsDb: "databases['notifications']",
      booksSharedWithMeDb: "databases['booksSharedWithMe']",
    },
    observe: {
      uid: 'userStatusChanged'
    },
    created: function() {
      initSingleton();
      this.userInfo = Singleton.userInfo;
      this.databases = Singleton.databases;
      this.photoCache = Singleton.photoCache;
      this.bookCache = Singleton.bookCache;
    },
    userStatusChanged: function() {
      // console.log("userStatusChanged", this.uid);
      this.connectActiveDatabases();
      // redirect anonymous if necessary
      if (this.uid === 'anonymous' && this.anonRedirect != '')
        window.location.replace(window.location.origin + this.anonRedirect);
    },
    /**
     * @method requestDatabase
     * @return Promise
     * Returns a promise to a database.
     *
     * Databases not ready until user is logged in
     *
     */
    requestDatabase: function(type) {
      if (!(type in this.databases))
        throw new Error("bad database request " + type);
      // console.log('requestDatabase:', type);
      if (this.databases[type] === false)
        this.databases[type] = true;
      this.connectActiveDatabases();
      return Singleton.databasePromises[type];
    },
    connectActiveDatabases: function() {
      if (this.uid === 'anonymous' || this.uid === '') {
        // no user, remove active databases
        for (var k in this.databases)
          this.databases[k].location = "";
      }
      else {
        for (var k in this.databases)
          this.databases[k].location = CommonUtils.getFirebaseUrl(k, this.uid);
      }
    },
    /**
     * @method logout
     */
    logout: function() {
      Singleton.authClient.unauth();
    },
    /**
     * @method createPhoto
     * @param {File} file local file
     * creates photo record in db, and uploads file to server
     */
    createPhoto: function(file, callback) {
      callback = callback || CommonUtils.noope;
      Singleton.photoCache.createPhotoFromFile(file, this.uid, function(err, photoRef) {
        if (err)
          return callback(err);
        this.myPhotosDb.ref.child(photoRef.key()).set(true, function(err) {
            if (err) debugger;
            callback(err, photoRef);
          });
      });
    },
    /**
     * @method createBook
     * @param {string} title title
     * @param {object} size size
     * @param {number} size.width inches
     * @param {number} size.height inches
     * @param {function} callback fn(err, bookRef)
     */
    createBook: function(title, size, callback) {
      callback = callback || CommonUtils.noope;
      this.bookCache.createBook(this.uid, title, size, function(err, ref) {
        if (err) 
          return callback(err);
        this.myBooksDb.ref.child(ref.key()).set(true, function(err) {
            if (err) debugger;
            callback(err, ref);
          });
      }.bind(this));
    },

    deleteBook: function(bookId) {
      this.databases['myBooks'].ref.child(bookId).remove();
      (new Firebase( CommonUtils.getFirebaseUrl('oneBook', bookId))).remove();
    },
    deleteNotification: function(notificationId) {
      (new Firebase( 
        CommonUtils.getFirebaseUrl('oneNotification', this.uid, notificationId)))
        .remove();
    }
  });
  })();
  </script>
</polymer-element>
