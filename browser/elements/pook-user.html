<link href="../vendor/polymer/polymer.html" rel="import">
<link href="pook-utils.html" rel="import">
<link rel="import" href="pook-book-cache.html">
<link rel="import" href="pook-photo-cache.html">

<!--
current user entry point

singleton, all instances share common state

    user = document.createElement('pook-user');
    user.requestDatabase(account).then( function(db) {
    });

@element pook-user
@group model

-->
<polymer-element name='pook-user' anonRedirect="">
  <template></template>
  <script>
  (function() {

  "use strict";

  // Stuff common to all pook-user instances
  var Singleton = {
  
    // user information, from firebase.onAuth
    userInfo: {
    /**
     * @property uid
     * @type string
     * uid can have three states:
     *
     * "" means uninitialized
     *
     * 'anonymous' means user not logged in
     *
     * everything else is auth.uid
     */
      uid: '',
    /**
     * @property email
     * @type string
     */
      email: ''   
    },
    authClient: new Firebase( PookUtils.firebaseLoc ),

    /* 
    User related databases
    User databases contain $userId in their path, and can only be loaded after we know userId
    Requests for user database return Promise, which is fullfilled when user authenticates

    state can have 3 values:
    false: database has not been requested
    true: database has been requested
    object: this is the database, firebase-element
    */  
    databases: {
      account: false,
      user: false,
      myPhotos: false,
      myBooks: false
    },
    databasePromises : {
      account: new PookPromise(),
      user: new PookPromise(),
      myPhotos: new PookPromise(),
      myBooks: new PookPromise()
    },
    /**
     * @property photoCache
     * @type pook-photo-cache
     * [pook-photo-cache](#pook-proxy-photo-cache.html)
     */
    get photoCache() {
      if (!('_photoCache' in this))
        this._photoCache = document.createElement('pook-photo-cache');
      return this._photoCache;
    },

    get bookCache() {
      if (!('_bookCache' in this))
        this._bookCache = document.createElement('pook-book-cache');
      return this._bookCache;
    }
  };

  Singleton.authClient.onAuth( function(user) {
      Singleton.userInfo.uid = user ? user.uid : 'anonymous';
      Singleton.userInfo.email = user ? user.password.email : '';
    }
  );


  Polymer({
    publish: {
      /** if set, will redirect to anonRedirect path if user is 'anonymous' */
      anonRedirect: '',
      userInfo: null,
      databases: null,
      /**
       * @property photoCache
       * @type pook-photo-cache
       */
      photoCache: null,
      /**
       * @property bookCache
       * @type pook-book-cache
       */
      bookCache: null
    },
    computed: {
      uid: 'userInfo.uid',
      email: 'userInfo.email',
      /**
       * @property account
       * @type object
       * convenience access to /users/$userId/account
       */
      account: "databases['account'].data",
      userData: "databases['user'].data",
      myPhotos: "databases['myPhotos'].data",
      myBooks: "databases['myBooks'].data"
    },
    observe: {
      uid: 'userStatusChanged'
    },
    created: function() {
      this.userInfo = Singleton.userInfo;
      this.databases = Singleton.databases;
      this.photoCache = Singleton.photoCache;
      this.bookCache = Singleton.bookCache;
    },
    userStatusChanged: function() {
      // console.log("userStatusChanged", this.uid);
      this.connectActiveDatabases();
      // redirect anonymous if necessary
      if (this.uid === 'anonymous' && this.anonRedirect != '')
        window.location.replace(window.location.origin + this.anonRedirect);
    },
    /**
     * @method requestDatabase
     * @return Promise
     * Returns a promise to a database.
     *
     * Databases not ready until user is logged in
     *
     */
    requestDatabase: function(type) {
      if (!(type in this.databases))
        throw new Error("bad database request " + type);
      // console.log('requestDatabase:', type);
      if (this.databases[type] === false)
        this.databases[type] = true;
      this.connectActiveDatabases();
      return Singleton.databasePromises[type];
    },
    connectActiveDatabases: function() {
      if (this.uid === 'anonymous' || this.uid === '') {
        // no user, remove active databases
        for (var k in this.databases)
          if ((typeof this.databases[k]) === 'object')
            this.databases[k] = true;
      }
      else {
        for (var k in this.databases)
          if (this.databases[k] === true) {
            this.databases[k] = document.createElement('firebase-element');
            this.databases[k].location = PookUtils.getFirebaseUrl(k, this.uid);
            Singleton.databasePromises[k].resolve(this.databases[k]);
            // this.databases[k].log = true;
            // if (k == 'account') {
            //   var obs = new PathObserver(this.databases[k], 'data.email');
            //   obs.open( function(newValue, oldValue) {
            //     console.log('email changed');
            //     if (oldValue && newValue)
            //       console.log('email really changed');
            //   });

            // }
          }
      }
    },
    /**
     * @method logout
     */
    logout: function() {
      Singleton.authClient.unauth();
    },
    /**
     * @method createPhoto
     * @param <File> file local file
     * creates photo record in db, and uploads file to server
     */
    createPhoto: function(file, callback) {
      callback = callback || PookUtils.noope;
      this.photoCache.createPhotoFromFile(file, this.uid, function(err, photoRef) {
        if (err)
          return callback(err);
        this.requestDatabase('myPhotos').then( function(db) {
          db.ref.child(photoRef.key()).set(true, function(err) {
            if (err) debugger;
            callback(err, photoRef);
          });
        })
      }.bind(this)
      );
    },
    /**
     * @method createBook
     * 
     */
    createBook: function(title, size, callback) {
      callback = callback || PookUtils.noope;
      this.bookCache.createBook(this.uid, title, size, function(err, ref) {
        if (err) 
          return callback(err);
        this.requestDatabase('myBooks').then( function(db) {
          db.ref.child(ref.key()).set(true, function(err) {
            if (err) debugger;
            callback(err, ref);
          })
        }.bind(this));
      }.bind(this));
    },

    deleteBook: function(bookId) {
      this.databases['userBooks'].ref.child(bookId).remove();
    }
  });

  })();
  </script>
</polymer-element>
